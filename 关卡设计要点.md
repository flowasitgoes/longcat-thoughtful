# Longcat 关卡设计要点

> 本文档基于学术论文《Procedural Content Generation for Longcat Puzzle Game》整理

## 核心概念

### 1. 游戏机制
- **Perfect Fill**: 全部格子必须被猫走完（不可遗漏）
- **Hamiltonian Path**: 从起点到终点，经过所有可走格子的唯一路径
- **90度转弯**: 路径必须严格90度转弯（不允许对角线移动）
- **可循环**: 路径允许形成循环（从起点回到终点）

### 2. 难度设计理念

**难度 ≠ 转弯数量**

**难度 = Mask（地形形状）的拓扑复杂度**

- **地形形状复杂度**: 凹槽、峡道、凸出部、洞、不规则形状
- **可选空间拓扑复杂度**: 玩家在面对多个选择时的困难程度
- **路径约束程度**: 路径的唯一性（是否存在唯一解）

#### 难度等级示例：
- **简单**: 巨大外框 + 中间一个大洞
- **中等**: 复杂 S 型外框
- **困难**: 左边狭窄 + 中间洞 + 复杂外围
- **非常困难**: 上下凹槽很深的奇怪形状

## Mask（地形形状）设计

### 三种设计方式

#### 方式 A：手工画（官方游戏最常用）
- 手工设计不同复杂度的 pattern
- **Easy**: 外框 + 大洞
- **Medium**: 外框 + 洞 + L 凹槽
- **Hard**: 凹 T 形、C 形、不对称走廊
- **Expert**: 连续狭窄通道、错觉路线
- 交给 path solver 找出唯一解
- 存起来当作关卡库

#### 方式 B：预定义地形模板（20-40种）
模板类型：
- Rectangle with hole（矩形带洞）
- U-shape（U 形）
- S-shape（S 形）
- Offset large square（偏移大方块）
- Chair-like shape（椅子形）
- Spiral-like frame（螺旋框架）

变换操作：
- 坐标镜像
- 旋转
- 随机挤压

#### 方式 C：算法生成 Mask（自动化）
生成方法：
- Random fractal subdivision（随机分形细分）
- Cellular automata（细胞自动机）
- Flood-fill 型凹槽产生器
- BSP Dungeon Generator（BSP 地牢生成器）
- Grid carving（网格雕刻）

验证步骤：
1. 检查地形是否连通
2. 检查无死角（dead-end diagnosis）
3. 丢给 Hamiltonian path solver
4. 用 solver 成功率当「困难度标记」

## 数据结构

### Level 数据结构
```typescript
interface Level {
  width: number;      // 网格宽度
  height: number;     // 网格高度
  mask: boolean[][];  // 地形遮罩（true = 可走，false = 不可走）
  start: {x: number, y: number};  // 起点坐标
  end: {x: number, y: number};    // 终点坐标（可选，如果路径循环则等于起点）
  path?: {x: number, y: number}[]; // 生成的路径（可选）
}
```

### 关键约束
1. **Mask 连通性**: 所有可走格子必须连通
2. **无死角**: 不能有无法到达的死角
3. **Hamiltonian Path 存在性**: 必须存在一条能填满所有格子的路径
4. **路径唯一性**: 理想情况下只有一条解（难度更高）

## 路径生成算法

### 核心算法：Hamiltonian Path Solver

#### 算法类型
1. **DFS/Backtracking**: 深度优先搜索 + 回溯
2. **Constraint Propagation**: 约束传播
3. **Heuristic Search**: 启发式搜索

#### 关键检查点
1. **连通性检查**: 确保剩余未访问格子仍然连通
2. **奇偶性检查**: 检查剩余格子的奇偶性（某些情况下可以提前判断无解）
3. **Dead-end 检测**: 检测是否会产生死胡同
4. **唯一解验证**: 验证是否存在多条解（如果需要唯一解）

## 两种生成方法：Puzzle-Up vs Solution-Down

### Puzzle-Up（自下而上）
**流程**：
1. 先随机或半随机构建关卡状态（放置所有必要元素）
2. 然后寻找所有解
3. 如果没有解，重新生成

**特点**：
- ✅ 可以找到任何可能的关卡
- ❌ 可能生成很多无解关卡，非常慢
- ❌ 对于 Longcat，只有 5.54% 的迭代能生成可解关卡
- ❌ PCGRL 的 Turtle 方法在 Longcat 上完全失败（0% 可解性）

**适用场景**：关卡元素较少、约束较宽松的游戏

### Solution-Down（自上而下）⭐ 推荐
**流程**：
1. 先创建解决方案（基于游戏可能的动作）
2. 从解决方案创建关卡，保持约束以保留解
3. 保证生成可解关卡

**特点**：
- ✅ **100% 可解性保证**
- ✅ 速度快（不需要重新生成无解关卡）
- ✅ 适合 Longcat 这种约束严格的游戏
- ⚠️ 可能产生多个解（不一定是唯一解）
- ⚠️ 可能产生过于简单的关卡

**Solution-Down 生成器伪代码**：
```
1. 创建空关卡（指定大小）
2. 随机选择起点位置，放置猫头
3. 检查猫头周围哪些空间是空的
4. 随机选择一个有空格子的方向
5. 在当前位置放置猫身体，将猫头移动到随机选择的方向
6. 如果这个移动产生转弯，在转弯处放置墙（如果该位置没有猫身体）
7. 如果猫头周围还有空位，回到步骤 3
8. 创建关卡副本：将所有空位填满墙，移除所有猫身体，将猫头移回起点
9. 保存为完整生成的关卡
```

**关键洞察**：如果有转弯，必须有墙让猫停下来。由于生成过程与解决关卡的时间顺序相同，转弯处会有猫身体，所以可以生成随机动作并考虑必须存在的墙。

## 图表示法（Graph Representation）

### 核心概念
将 Longcat 关卡表示为**状态图**，而不是网格表示：
- **节点（Node）**: 每个棋盘配置（状态）
- **边（Edge）**: 每个动作（移动方向）

### 状态类型
1. **起始状态（Start State）**: 关卡开始时的状态
2. **成功状态（Success State）**: 关卡完成的状态（绿色节点）
3. **失败状态（Fail State）**: 必须重启关卡的状态（红色节点）
4. **可达状态（Reachable State）**: 从该状态可以到达解（蓝色节点）
5. **死状态（Dead State）**: 关卡被分割成两个空区域的状态（紫色节点）
   - 玩家明显知道无解，不会继续探索
6. **不确定状态（Indeterminate State）**: 不是解、成功、失败或死状态的状态（黄色节点）
   - 不会导致解，但玩家不明显知道这一点

### 关键变量（用于难度预测）

#### 最重要的变量
1. **Number of indeterminate branches（不确定分支数）** ⭐
   - 不确定状态中出度大于 1 的分支数
   - 玩家需要选择但不知道是否可解的状态数
   - **与难度最相关**

2. **Number of solutions（解的数量）**
   - 成功状态的数量
   - 更多解 = 更容易找到解 = 难度降低

3. **Number of solution branches（解分支数）**
   - 解路径上的分支数
   - 玩家在解路径上可能做错的动作数
   - 更多分支 = 更容易走错 = 难度增加

#### 其他相关变量
4. **Number of indeterminate states（不确定状态数）**
   - 与难度相关，但可能被生成器利用（创建长隧道）
   - 最终被 indeterminate branches 替代

5. **Shortest solution length（最短解长度）**
   - 从起始节点到最近解节点的最短路径长度
   - 与难度相关，但可能被利用（创建长但简单的路径）

6. **Number of states（状态总数）**
   - 图中的节点数
   - 更多状态 = 需要搜索更多状态

7. **Number of branches（分支总数）**
   - 出度大于 1 的节点数
   - 与 indeterminate branches 高度相关

8. **Number of fails（失败状态数）**
   - 失败状态的数量
   - 与状态数高度相关

9. **Size（大小）**
   - 网格中的格子数
   - 与难度相关性较弱

## 难度预测器

### 方法
基于 Kreveld et al. 的工作，使用**线性回归**（Ridge Regression）：
- 使用玩家完成时间作为难度标签（12,000 名玩家，250 个关卡）
- 最终 MSE: 150.76

### 最终使用的变量
```python
# 最终模型使用的变量
variables = [
    "Number of indeterminate branches",  # 最重要
    "Number of solutions",               # 负相关
    "Number of solution branches"        # 正相关
]
```

### 迭代过程
1. **Iteration 1**: 简单线性回归，MSE = 204.73
2. **Iteration 2**: 变量选择，MSE = 199.00
3. **Iteration 3**: Lasso 回归，MSE = 200.75
4. **Iteration 4**: Ridge 回归，MSE = 181.89
5. **Iteration 5**: 使用 indeterminate states，MSE = 150.76
6. **Final**: 使用 indeterminate branches（避免隧道问题），MSE ≈ 150

### 关键发现
- **隧道问题（Tunnel Problem）**: 长但简单的路径会增加 indeterminate states，但不增加难度
- **解决方案**: 使用 indeterminate branches 而不是 indeterminate states
- **死状态**: 玩家明显知道无解，不会探索，因此不计入难度

## 关卡设计流程

### 设计流程
1. **设计 Mask**: 
   - 手工设计或使用模板/算法生成
   - 确保 Mask 连通且无死角

2. **验证 Mask**:
   - 检查连通性
   - 检查无死角
   - 检查是否有足够空间形成 Hamiltonian Path

3. **生成路径**:
   - 使用 Hamiltonian Path Solver
   - 验证路径存在性
   - 如果要求唯一解，验证唯一性

4. **难度评估**:
   - 基于 Mask 复杂度
   - 基于路径约束程度
   - 基于可选空间拓扑复杂度

5. **存储关卡**:
   - 存储 Mask 数据
   - 存储路径数据（可选，用于验证）
   - 存储难度标签

## 实现要点

### TypeScript/Node.js 实现

#### 1. Mask 表示
```typescript
type Mask = boolean[][];  // true = walkable, false = blocked

interface Level {
  width: number;
  height: number;
  mask: Mask;
  start: Point;
  end?: Point;
}
```

#### 2. 路径表示
```typescript
type Point = {x: number, y: number};
type Path = Point[];

interface Solution {
  path: Path;
  isUnique: boolean;
  difficulty: number;
}
```

#### 3. 核心函数
```typescript
// 生成 Hamiltonian Path
function solveHamiltonianPath(level: Level): Path | null;

// 验证路径有效性
function validatePath(level: Level, path: Path): boolean;

// 检查 Mask 连通性
function checkConnectivity(mask: Mask): boolean;

// 检查无死角
function checkNoDeadEnds(mask: Mask): boolean;

// 评估难度
function evaluateDifficulty(level: Level, path: Path): number;
```

## Unity 项目分析

### 项目结构
- **关卡存储**: 使用 Unity Scene 文件（`.unity`）
- **关卡数据**: 使用 `LevelData` ScriptableObject
- **关卡加载**: 通过 `LevelLoader` 和 `GameManager` 加载场景
- **起点/终点**: 使用 `StartingBlock` 和 `GoalBlock`

### 关键发现
1. **手工设计**: 关卡通过 Unity 编辑器手工设计
2. **场景文件**: 每个关卡是一个独立的 Unity Scene
3. **元数据**: `LevelData` 包含 worldNumber, levelNumber, catStartingHeight
4. **没有程序化生成**: 当前项目没有程序化生成关卡的代码

## PCGRL（Procedural Content Generation via Reinforcement Learning）

### 核心思想
将关卡设计框架化为**游戏**，逐步采取行动创建关卡。使用强化学习学习最大化某些期望关卡特征的动作。

### SD-PCGRL（Solution-Down PCGRL）

#### 环境
- **动作空间**: 4 个方向（上、下、左、右）
- **状态空间**: 当前关卡状态（2D 数组）
- **输入**: 卷积神经网络，输入为 (n*2-1)²（例如 8x8 关卡 = 15x15 输入）
- **保证**: 100% 可解性

#### 奖励函数
- **仅关注难度**（因为可解性已保证）
- 奖励增加难度
- 惩罚降低难度

#### 网络架构
```
输入层 (15x15 for 8x8 level)
  ↓
卷积层 1
  ↓
卷积层 2
  ↓
Max Pool
  ↓
卷积层 3
  ↓
卷积层 4
  ↓
Max Pool
  ↓
全连接层 1
  ↓
全连接层 2
  ↓
输出层 (4 actions)
```

#### 训练参数
- **训练轮数**: 200,000 episodes（约 4 天）
- **学习率**: 0.0007
- **折扣因子**: 0.9
- **Epsilon**: 1.0 → 0.0（线性衰减）
- **Replay Buffer**: 600 个动作
- **Mini-batch**: 64
- **Target Network Sync**: 每 10 episodes

#### 温度采样（Temperature Sampling）
- **Temperature = 1.0**: 完全随机（等同于随机生成器）
- **Temperature = 0.0**: 完全确定性（高重复率）
- **最佳温度**: 0.2-0.3（平衡难度分布和多样性）

### 实验结果

#### 可解性
- **SD-PCGRL**: 100% ✅
- **Solution-Down Random**: 100% ✅
- **Puzzle-Up Random**: 5.54% ❌
- **Turtle PCGRL**: 0% ❌

#### 重复率（Duplicates）
- **Solution-Down Random**: 9.68%
- **SD-PCGRL (temp=1.0)**: 9.68%
- **SD-PCGRL (temp=0.3)**: 41.0%
- **SD-PCGRL (temp=0.2)**: 更高
- **Puzzle-Up Random**: 68.56%

#### 难度分布
- **SD-PCGRL (temp=0.2-0.3)**: 更好的难度分布
- **非平凡关卡比例**:
  - SD-PCGRL (temp=0.3): 28.64%
  - Solution-Down Random: 8.24%
- **高难度关卡** (80-200): SD-PCGRL (temp=0.2) 生成 24 倍于随机生成器

#### 难度范围分析
- **0-20（平凡）**: 随机生成器生成最多（91.1% 的关卡）
- **20-50（简单-中等）**: SD-PCGRL 分布更均匀
- **50-80（困难）**: SD-PCGRL 明显更多
- **80-200（非常困难）**: SD-PCGRL 占主导

## 下一步实现计划

### Phase 1: 构建 Level 模型和基础工具
- [ ] 定义 `Level` 接口（width, height, mask, start）
- [ ] 实现 Mask 验证函数（连通性、无死角）
- [ ] 实现图表示法（Graph Representation）
- [ ] 实现状态类型分类（成功、失败、死状态、不确定状态）
- [ ] 实现 Mask 可视化（Angular 组件）

### Phase 2: 实现 Solution-Down 生成器（优先）
- [ ] 实现基础 Solution-Down 随机生成器
- [ ] 实现路径生成逻辑（基于动作序列）
- [ ] 实现墙放置逻辑（转弯处放置墙）
- [ ] 测试可解性（应该 100%）

### Phase 3: 实现难度预测器
- [ ] 实现图分析工具（提取所有状态和边）
- [ ] 实现关键变量计算：
  - [ ] Number of indeterminate branches
  - [ ] Number of solutions
  - [ ] Number of solution branches
- [ ] 实现 Ridge Regression 模型
- [ ] 使用真实玩家数据训练（如果有）或生成训练数据

### Phase 4: 实现 SD-PCGRL（可选，高级）
- [ ] 实现 DQN 网络架构
- [ ] 实现强化学习环境（Solution-Down MDP）
- [ ] 实现奖励函数（基于难度预测器）
- [ ] 实现训练循环
- [ ] 实现温度采样

### Phase 5: 实现 Mask 生成器（可选）
- [ ] 实现模板系统（方式 B）
- [ ] 实现算法生成（方式 C）
- [ ] 与 Solution-Down 生成器集成

### Phase 6: Angular 集成
- [ ] 实现网格渲染组件
- [ ] 实现路径动画
- [ ] 实现关卡编辑器（可选）
- [ ] 实现难度可视化

## 参考资源

### 相关算法
- Hamiltonian Path Problem
- Constraint Satisfaction Problem (CSP)
- Backtracking Algorithms
- Graph Connectivity Algorithms

### 相关游戏
- Snake Puzzle Games
- Fill Puzzle Games
- Path Puzzle Games

## 关键实现细节

### Solution-Down 生成器实现要点

1. **转弯检测**:
   ```python
   # 如果移动方向改变，需要放置墙
   if current_direction != previous_direction:
       place_wall_at_turn_position()
   ```

2. **墙放置规则**:
   - 转弯处必须放置墙（让猫停下来）
   - 如果转弯处已有猫身体，不放置墙
   - 确保不破坏连通性

3. **关卡完成**:
   - 所有空位填满墙
   - 移除所有猫身体
   - 猫头回到起点
   - 保证有唯一解（生成的路径）

### 图表示法实现要点

1. **状态枚举**:
   ```python
   def enumerate_all_states(level):
       # 使用 BFS 从起始状态开始
       # 记录所有可达状态
       # 分类状态类型
   ```

2. **状态分类**:
   - 检查是否完成（所有格子被填满）
   - 检查是否失败（无合法移动）
   - 检查是否死状态（分割成两个区域）
   - 其他为不确定状态

3. **分支计算**:
   ```python
   def count_indeterminate_branches(graph):
       branches = 0
       for state in indeterminate_states:
           if state.out_degree > 1:
               branches += state.out_degree - 1
       return branches
   ```

## 注意事项

1. **性能考虑**: 
   - Hamiltonian Path 问题是 NP-Complete，对于大网格可能需要优化
   - 图表示法对于大关卡可能状态爆炸（Longcat 最大观察到 1151 个状态）
   - Solution-Down 方法比 Puzzle-Up 快得多

2. **唯一解**: 
   - Solution-Down 保证至少一个解，但可能产生多个解
   - 如果需要唯一解，需要额外验证

3. **难度平衡**: 
   - 使用 indeterminate branches 而不是 indeterminate states（避免隧道问题）
   - 避免创建长但简单的路径
   - 需要测试和调整难度评估标准

4. **用户体验**: 
   - Solution-Down 生成速度快（100% 可解性）
   - 温度采样可以平衡难度和多样性
   - 建议使用 temperature 0.2-0.3

5. **重复率**: 
   - 低温度会产生更多重复
   - 需要在难度分布和多样性之间平衡
   - 可以使用温度采样或增加随机性

## 论文关键结论

1. **Solution-Down 方法对 Longcat 非常有效**（100% 可解性 vs 5.54%）
2. **Puzzle-Up 方法不适合 Longcat**（约束太严格）
3. **SD-PCGRL 可以生成更多非平凡关卡**（28.64% vs 8.24%）
4. **难度预测的关键变量**：indeterminate branches, solutions, solution branches
5. **图表示法是强大的设计工具**，可以量化关卡复杂度

